// ======================================================================
/*!
 * \brief Manage access to the repository
 */
// ======================================================================

#pragma once

#include "Repository.h"
#include <boost/thread.hpp>
#include <macgyver/Cache.h>
#include <macgyver/DirectoryMonitor.h>
#include <spine/Thread.h>
#include <atomic>
#include <memory>

namespace SmartMet
{
namespace Engine
{
namespace Querydata
{
// Collection of files
using Files = std::vector<boost::filesystem::path>;

struct RepoManager
{
  // construction & destruction

  ~RepoManager();
  RepoManager(const std::string& configfile);

  // generic API

  const ProducerConfig& producerConfig(const Producer& producer) const;

  // callback requests

  void update(Fmi::DirectoryMonitor::Watcher id,
              boost::filesystem::path dir,
              boost::regex pattern,
              Fmi::DirectoryMonitor::Status status);

  void error(Fmi::DirectoryMonitor::Watcher id,
             boost::filesystem::path dir,
             boost::regex pattern,
             std::string message);

  void init();
  bool ready() const;
  void shutdown();
  void shutdownRequestFlagSet();

  // data members

  mutable Spine::MutexType itsMutex;  // mutexes should always be mutable
  const std::string itsConfigFile;
  libconfig::Config itsConfig;
  bool itsVerbose;

  Fmi::DirectoryMonitor itsMonitor;
  boost::thread itsMonitorThread;

  // info on producers generated by constructor

  typedef std::list<ProducerConfig> ProducerConfigList;
  ProducerConfigList itsConfigList;

  // available producers

  ProducerList itsProducerList;

  // watchers and the respective producer

  typedef std::map<Fmi::DirectoryMonitor::Watcher, Producer> ProducerMap;
  ProducerMap itsProducerMap;

  // loaded data, updated regularly

  Repository itsRepo;

  std::time_t configModTime;  // Timestamp of configuration file loaded
  inline std::time_t getConfigModTime() { return configModTime; }

 private:
  void load(Producer producer, Files files);

  Fmi::DirectoryMonitor::Watcher id(const Producer& producer) const;
  RepoManager();

  std::atomic<int> itsThreadCount;
  int itsMaxThreadCount;
  bool itsShutdownRequested;

  using LatLonCache = Fmi::Cache::Cache<std::size_t, boost::shared_ptr<std::vector<NFmiPoint>>>;

  LatLonCache itsLatLonCache;
};

}  // namespace Q
}  // namespace Engine
}  // namespace SmartMet

// ======================================================================
